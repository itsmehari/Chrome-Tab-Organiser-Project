function getBaseDomain(e){if(!e||"string"!=typeof e)return null;try{return new URL(e).hostname}catch(e){return null}}function getFavicon(e){return e.favIconUrl||`https://www.google.com/s2/favicons?domain=${getBaseDomain(e.url)}`}function getTitle(e){return e.title||getBaseDomain(e.url)||e.url}async function analyzeTabs(e=null){try{const t=await chrome.windows.getAll({populate:!0}),s={};for(const e of t)for(const t of e.tabs){const e=getBaseDomain(t.url);e&&(s[e]||(s[e]={domain:e,tabCount:0,favicon:getFavicon(t),title:getTitle(t),urls:[],tabIds:[]}),s[e].tabCount++,s[e].urls.push(t.url),s[e].tabIds.push(t.id))}let a=Object.values(s);return null!==e&&(a=a.filter(t=>t.tabCount>e)),a.sort((e,t)=>t.tabCount-e.tabCount),{success:!0,data:a}}catch(e){return console.error("Error analyzing tabs:",e),{success:!1,error:e.message}}}async function groupTabsInChunks(e,t){const s=e.map(e=>e.id),a=taborgSettings.chunkSize||(e.length>250?50:25),r=[];for(let e=0;e<s.length;e+=a)r.push(s.slice(e,e+a));const o=[];for(let e=0;e<r.length;e++){const s=r[e];if(0===s.length)continue;const a=await chrome.windows.create({tabId:s[0],state:"normal"});s.length>1&&await chrome.tabs.move(s.slice(1),{windowId:a.id,index:-1});const n=await chrome.tabs.group({tabIds:s}),c=r.length>1?`${t} (Part ${e+1})`:t;await chrome.tabGroups.update(n,{title:c}),o.push(n)}return o}async function organizeTabsByDomain(){try{const e=(await chrome.tabs.query({})).filter(e=>void 0!==e.groupId&&-1!==e.groupId).map(e=>e.id);e.length>0&&await chrome.tabs.ungroup(e);const t=await chrome.tabs.query({}),s={};for(const e of t)if(e.url){const t=getBaseDomain(e.url);t&&(s[t]||(s[t]=[]),s[t].push(e))}const a=[],r=[];let o=0;for(const e in s){const t=s[e];if(t.length>5){const s=await groupTabsInChunks(t,e);a.push(...s),o++}else r.push(...t)}return{success:!0,message:`Organized tabs for ${o} domain(s).`,groupIds:a,scatteredTabs:r.map(e=>e.id)}}catch(e){return console.error("Error organizing all tabs:",e),{success:!1,error:e.message}}}async function groupSpecificTabs(e){try{if(!e||0===e.length)return{success:!0,message:"No tabs to group."};const t=(await chrome.tabs.query({})).filter(t=>e.includes(t.id)),s=await groupTabsInChunks(t,"Scattered Tabs");return{success:!0,message:`Grouped ${t.length} scattered tabs.`,groupIds:s}}catch(e){return console.error("Error grouping specific tabs:",e),{success:!1,error:e.message}}}async function organizeTabsForDomain(e){try{const t=(await chrome.tabs.query({url:`*://${e}/*`})).filter(e=>void 0===e.groupId||-1===e.groupId);if(t.length<=5)return{success:!0,message:`Only ${t.length} ungrouped tabs found for ${e}. A minimum of 6 is required.`};const s=await groupTabsInChunks(t,e);return{success:!0,message:`Grouped ${t.length} tabs for ${e}.`,groupIds:s}}catch(e){return console.error("Error organizing tabs for domain:",e),{success:!1,error:e.message}}}async function closeAllTabsForDomain(e){try{const t=await chrome.windows.getAll({populate:!0}),s=[];for(const a of t)for(const t of a.tabs)getBaseDomain(t.url)===e&&s.push(t.id);return 0===s.length?{success:!0,message:`No tabs to close for ${e}.`}:(await chrome.tabs.remove(s),{success:!0,message:`Closed ${s.length} tabs for ${e}.`})}catch(e){return console.error("Error closing tabs for domain:",e),{success:!1,error:e.message}}}importScripts("lib/compromise.min.js");let creatingOffscreenDocumentPromise,taborgSettings={},lastCreatedGroupIds=[],redoStack=[];function safeStorageGet(e,t){chrome.storage&&chrome.storage.local&&"function"==typeof chrome.storage.local.get?chrome.storage.local.get(e,t):(console.warn("chrome.storage.local.get is not available in this context."),t({}))}function loadSettings(){safeStorageGet(["taborg_settings"],e=>{taborgSettings=e.taborg_settings||{chunkSize:null}})}function saveUndoState(e){lastCreatedGroupIds=Array.isArray(e)?e:[e],redoStack=[]}async function undoLastAction(){if(lastCreatedGroupIds.length>0){const e=[...lastCreatedGroupIds].reverse();let t=0;for(const s of e){const e=await chrome.tabs.query({groupId:s});e.length>0&&(t++,redoStack.push({groupId:s,tabIds:e.map(e=>e.id)}),await chrome.tabs.ungroup(e.map(e=>e.id)))}return lastCreatedGroupIds=[],{success:!0,message:`Undid ${t} group(s).`}}return{success:!1,message:"Nothing to undo."}}async function redoLastAction(){if(redoStack.length>0){const e=redoStack.pop(),t=await chrome.tabs.group({tabIds:e.tabIds});return lastCreatedGroupIds=[t],{success:!0,message:"Redo successful."}}return{success:!1,message:"Nothing to redo."}}async function getComprehensiveStats(){try{const e=await chrome.windows.getAll({populate:!0}),t=e.flatMap(e=>e.tabs),s=await chrome.tabGroups.query({}),a=t.length,r=e.length,o=s.length,n=t.filter(e=>e.audible).length,c=t.filter(e=>e.discarded).length,i={};t.forEach(e=>{e.url&&(i[e.url]=(i[e.url]||0)+1)});return{success:!0,totalTabs:a,totalWindows:r,totalGroups:o,audibleTabs:n,discardedTabs:c,duplicateTabs:Object.values(i).filter(e=>e>1).reduce((e,t)=>e+(t-1),0)}}catch(e){return console.error("Error getting comprehensive stats:",e),{success:!1,error:e.message}}}async function closeDuplicateTabs(){try{const e=await chrome.tabs.query({}),t={},s=[];for(const a of e)a.url&&(t[a.url]?s.push(a.id):t[a.url]=a.id);return s.length>0&&await chrome.tabs.remove(s),{success:!0,count:s.length,message:`Closed ${s.length} duplicate tab(s).`}}catch(e){return console.error("Error closing duplicate tabs:",e),{success:!1,error:e.message}}}async function findAndFocusAudibleTab(){try{const e=await chrome.tabs.query({audible:!0});if(e.length>0){const t=e[0];return await chrome.windows.update(t.windowId,{focused:!0}),await chrome.tabs.update(t.id,{active:!0}),{success:!0}}return{success:!1,message:"No audible tabs found."}}catch(e){return console.error("Error focusing audible tab:",e),{success:!1,error:e.message}}}async function getGroupingSuggestions(){try{const e=await chrome.tabs.query({nogroup:!0}),t={};for(const s of e){const e=getBaseDomain(s.url);e&&(t[e]||(t[e]={domain:e,count:0,favicon:getFavicon(s)}),t[e].count++)}return{success:!0,data:Object.values(t).filter(e=>e.count>5)}}catch(e){return console.error("Error getting grouping suggestions:",e),{success:!1,error:e.message}}}async function saveTabsForLater(e){const t=await chrome.tabs.query({url:`*://${e}/*`});if(0===t.length)throw new Error(`No tabs found for domain: ${e}`);const s={name:`Tabs from ${e}`,timestamp:Date.now(),urls:t.map(e=>e.url),favicon:t[0].favIconUrl||null},{savedGroups:a}=await chrome.storage.local.get("savedGroups");a.unshift(s),await chrome.storage.local.set({savedGroups:a});const r=t.map(e=>e.id);return await chrome.tabs.remove(r),{message:`Saved ${t.length} tab(s) from ${e}.`}}async function getSavedGroups(){const{savedGroups:e}=await chrome.storage.local.get("savedGroups");return{groups:e||[]}}async function restoreSavedGroup(e){const{savedGroups:t}=await chrome.storage.local.get("savedGroups"),s=t.find(t=>t.timestamp===Number(e));if(!s)throw new Error("Could not find the specified group to restore.");await chrome.windows.create({url:s.urls});const a=t.filter(t=>t.timestamp!==Number(e));return await chrome.storage.local.set({savedGroups:a}),{message:`Restored ${s.urls.length} tab(s).`}}async function deleteSavedGroup(e){let{savedGroups:t}=await chrome.storage.local.get("savedGroups");const s=t.length;if(t=t.filter(t=>t.timestamp!==Number(e)),t.length===s)throw new Error("Could not find the specified group to delete.");return await chrome.storage.local.set({savedGroups:t}),{message:"Group deleted successfully."}}async function setupOffscreenDocument(e){if(await(chrome.offscreen.hasDocument?.()))return;if(creatingOffscreenDocumentPromise)return void await creatingOffscreenDocumentPromise;const t=chrome.offscreen.createDocument({url:e,reasons:["CLIPBOARD"],justification:"To copy text to the clipboard"});creatingOffscreenDocumentPromise=t;try{await t}finally{creatingOffscreenDocumentPromise===t&&(creatingOffscreenDocumentPromise=null)}}async function copyUrlsByDomain(e){try{const t=(await chrome.tabs.query({url:`*://${e}/*`})).map(e=>e.url),s=t.join("\n");return await setupOffscreenDocument("offscreen.html"),await chrome.runtime.sendMessage({action:"copyToClipboard",target:"offscreen",data:s}),{success:!0,message:`Copied ${t.length} URLs for ${e}.`}}catch(e){return console.error("Error copying URLs:",e),{success:!1,error:e.message}}}async function analyzeTabContent(e){try{const t=await chrome.scripting.executeScript({target:{tabId:e},func:()=>document.body.innerText});if(t&&t[0]&&"string"==typeof t[0].result)return t[0].result}catch(e){}return""}function extractTopics(e){if(!e)return[];return nlp(e).nouns().out("frequency").slice(0,3).map(e=>e.normal)}async function suggestGroupsByContent(){const e=await chrome.tabs.query({url:["http://*/*","https://*/*"]}),t=await Promise.all(e.map(async e=>{const t=extractTopics(await analyzeTabContent(e.id));return{id:e.id,title:e.title,url:e.url,topics:t}})),s={};t.forEach(e=>{e.topics.forEach(t=>{s[t]||(s[t]=[]),s[t].push(e)})});const a=[];return Object.entries(s).forEach(([e,t])=>{t.length>2&&(a.some(e=>e.tabs.some(e=>e.id===t[0].id))||a.push({name:`Topic: ${e}`,tabs:t}))}),await chrome.storage.local.set({groupSuggestions:a}),await chrome.tabs.create({url:"preview.html"}),{success:!0}}chrome.storage&&"object"==typeof chrome.storage.onChanged&&"function"==typeof chrome.storage.onChanged.addListener?chrome.storage.onChanged.addListener((e,t)=>{"local"===t&&e.taborg_settings&&(taborgSettings=e.taborg_settings.newValue||{})}):console.warn("chrome.storage.onChanged or addListener is not available in this context (background).",chrome.storage&&chrome.storage.onChanged),loadSettings(),chrome.tabs.onCreated.addListener(async e=>{if(!taborgSettings.autoOrganize)return;const t=taborgSettings.autoOrganizeThreshold||5,s=getBaseDomain(e.url);if(!s)return;(await chrome.tabs.query({})).filter(e=>getBaseDomain(e.url)===s).length>t&&(saveUndoState(),organizeTabsForDomain(s))}),chrome.runtime.onInstalled.addListener(()=>{chrome.storage.local.get(["undoStack","redoStack","savedGroups"],e=>{e.undoStack||chrome.storage.local.set({undoStack:[]}),e.redoStack||chrome.storage.local.set({redoStack:[]}),e.savedGroups||chrome.storage.local.set({savedGroups:[]})})}),chrome.runtime.onMessage.addListener((e,t,s)=>((async()=>{try{let t;switch(e.action){case"organizeAll":t=await organizeTabsByDomain(),t.success&&t.groupIds&&saveUndoState(t.groupIds);break;case"groupScatteredTabs":t=await groupSpecificTabs(e.tabIds),t.success&&t.groupIds&&saveUndoState(t.groupIds);break;case"getDomainAnalysis":t={status:"success",domains:(await analyzeTabs(1)).data,suggestions:[]};break;case"getComprehensiveStats":t=await getComprehensiveStats();break;case"closeDuplicates":t=await closeDuplicateTabs();break;case"focusAudibleTab":t=await findAndFocusAudibleTab();break;case"getGroupingSuggestions":t=await getGroupingSuggestions();break;case"organizeByDomain":t=await organizeTabsForDomain(e.domain),t.success&&t.groupId&&saveUndoState(t.groupId);break;case"closeTabsByDomain":saveUndoState(),t=await closeAllTabsForDomain(e.domain);break;case"undo":t=await undoLastAction();break;case"redo":t=await redoLastAction();break;case"copyUrlsByDomain":t=await copyUrlsByDomain(e.domain);break;case"saveTabsForLater":t=await saveTabsForLater(e.domain);break;case"getSavedGroups":t=await getSavedGroups();break;case"restoreSavedGroup":t=await restoreSavedGroup(e.timestamp);break;case"deleteSavedGroup":t=await deleteSavedGroup(e.timestamp);break;case"suggestByContent":t=await suggestGroupsByContent();break;default:throw new Error(`Unknown action: ${e.action}`)}s({status:"success",...t})}catch(t){console.error(`Error during ${e.action}:`,t),s({status:"error",message:t.message})}})(),!0));